<?php

$(macro :unsafe) {
    __serializable_methods()
    $(_() as __context_AffectedByEndianness)
} >> function (\Yay\Ast $ast, \Yay\TokenStream $ts, \Yay\Index $start, \Yay\Index $end, \Yay\Engine $engine) {
    if (Vectory::isInteger() && Vectory::isSigned() && \in_array(Vectory::getBytesperElement(), [2, 4, 8], true)) {
        $append = new \Yay\Ast('__context_AffectedByEndianness');
        $append->push(new \Yay\Ast());
        $ast->append($append);
    }
} >> {
    private const SERIALIZATION_FORMAT_VERSION = 1;
    private const SUPPORTED_SERIALIZATION_FORMAT_VERSIONS = [
        self::SERIALIZATION_FORMAT_VERSION,
    ];
    
    public function serialize(): string
    {
        return \serialize([
            self::SERIALIZATION_FORMAT_VERSION,
            $( __context_AffectedByEndianness ? {
                \pack('S', 1) === \pack('v', 1),
            })
            $this->elementCount,
            $this->primarySource,
            $<Nullable>{ $this->nullabilitySource, }
        ]);
    }
    
    public function unserialize($serialized)
    {
        $errorMessage = 'Details unavailable';
        \set_error_handler(static function (int $errno, string $errstr) use (&$errorMessage): void {
            $errorMessage = $errstr;
        });
        $newValues = \unserialize(
            $serialized,
            ['allowed_classes' => [\ltrim($[FullyQualifiedClassName], '\\')]]
        );
        \restore_error_handler();
        
        if (false === $newValues) {
            __throw(
                \UnexpectedValueException,
                \sprintf('Failed to unserialize (%s)', $errorMessage)
            );
        }
        
        $expectedTypes = [
            'integer',
            $( __context_AffectedByEndianness ? { 'boolean', })
            'integer',
            'string',
            $<Nullable>{ 'string', }
        ];
            
        if (
            !\is_array($newValues)
            || \array_keys($newValues) !== \array_keys($expectedTypes)
            || \array_map('gettype', $newValues) !== $expectedTypes
        ) {
            $errorMessage = 'Expected an array of '.\implode(', ', $expectedTypes);
            __throw(
                \TypeError,
                \sprintf('Failed to unserialize (%s)', $errorMessage)
            );
        }
        
        $previousValues = [
            $this->elementCount,
            $this->primarySource,
            $<Nullable>{ $this->nullabilitySource, }
        ];
        
        [
            $version,
            $( __context_AffectedByEndianness ? { $littleEndian, })
            $this->elementCount,
            $this->primarySource,
            $<Nullable>{ $this->nullabilitySource, }
        ] = $newValues;
        
        if (!\in_array($version, self::SUPPORTED_SERIALIZATION_FORMAT_VERSIONS, true)) {
            $errorMessage = 'Unsupported version: '.$version;
            __throw(
                \UnexpectedValueException,
                \sprintf('Failed to unserialize (%s)', $errorMessage)
            );
        }

        $( __context_AffectedByEndianness ? {
            if ((\pack('S', 1) === \pack('v', 1)) !== $littleEndian) {
                $<Takes2>{
                    $pattern = '~(.)(.)~s';
                    $replacement = '${2}${1}';
                }
                $<Takes4>{
                    $pattern = '~(.)(.)(.)(.)~s';
                    $replacement = '${4}${3}${2}${1}';
                }
                $<Takes8>{
                    $pattern = '~(.)(.)(.)(.)(.)(.)(.)(.)~s';
                    $replacement = '${8}${7}${6}${5}${4}${3}${2}${1}';
                }
                $this->primarySource =
                    \preg_replace($pattern, $replacement, $this->primarySource);
            }
        })
        
        try {
            $<Boolean>{
                $expectedLength = (($this->elementCount + 7) >> 3);
            }
            $<!Boolean>{
                $expectedLength = $this->elementCount * $[BytesPerElement];
            }
            
            if (\strlen($this->primarySource) !== $expectedLength) {
                $errorMessage = \sprintf(
                    'Unexpected length of the primary source: expected %d bytes, found %d instead',
                    $expectedLength,
                    \strlen($this->primarySource)
                );
                __throw(
                    \LengthException,
                    \sprintf('Failed to unserialize (%s)', $errorMessage)
                );
            }
            
            $<Nullable>{
                $expectedLength = (($this->elementCount + 7) >> 3);
                if (\strlen($this->nullabilitySource) !== $expectedLength) {
                    $errorMessage = \sprintf(
                        'Unexpected length of the nullability source: expected %d bytes, found %d instead',
                        $expectedLength,
                        \strlen($this->nullabilitySource)
                    );
                    __throw(
                        \LengthException,
                        \sprintf('Failed to unserialize (%s)', $errorMessage)
                    );
                }
            }
            
            if ($this->elementCount < 0) {
                $errorMessage = 'The element count must not be negative';
                __throw(
                    \DomainException,
                    \sprintf('Failed to unserialize (%s)', $errorMessage)
                );
            }
        } catch (\Throwable $e) {
            [
                $this->elementCount,
                $this->primarySource,
                $<Nullable>{ $this->nullabilitySource, }
            ] = $previousValues;
            throw $e;
        }
    }
}