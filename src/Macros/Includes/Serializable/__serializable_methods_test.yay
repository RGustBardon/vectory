<?php

$(macro :unsafe) {
    __serializable_methods_test()
    $(_() as __context_AffectedByEndianness)
} >> function (\Yay\Ast $ast, \Yay\TokenStream $ts, \Yay\Index $start, \Yay\Index $end, \Yay\Engine $engine) {
    if (Vectory::isInteger() && Vectory::isSigned() && \in_array(Vectory::getBytesperElement(), [2, 4, 8], true)) {
        $append = new \Yay\Ast('__context_AffectedByEndianness');
        $append->push(new \Yay\Ast());
        $ast->append($append);
    }
} >> {
    /**
     * @depends testArrayAccess
     * @depends testCountable
     * @depends testIteratorAggregate
     */
    public function testSerializable(): void
    {
        $vector = self::getInstance();
        self::assertSerialization([], \serialize($vector));
        
        $value = self::getRandomValue();
        $sequence = [$value, self::getRandomValue(), $value];
        foreach ($sequence as $value) {
            $vector[] = $value;
        }
        $vector[4] = $[DefaultValue];
        \array_push($sequence, $[DefaultValue], $[DefaultValue]);
        self::assertSerialization($sequence, \serialize($vector));
    }
    
    $( __context_AffectedByEndianness ? {
        /**
         * @depends testSerializable
         */
        public function testSerializableWithDifferentEndianness(): void
        {
            $vector = self::getInstance();
            $sequence = [
                self::getRandomValue(),
                self::getRandomValue(),
                $<Nullable>{ null, }
                $<!Nullable>{ $[DefaultValue], }
            ];
            foreach ($sequence as $value) {
                $vector[] = $value;
            }
            $serialized = \serialize($vector);
            
            $littleEndianPosition = \strpos($serialized, ';b:') + 3;
            $serialized[$littleEndianPosition] = (string) \abs(1 - (int) $serialized[$littleEndianPosition]);
            
            $primarySourcePosition = \strpos($serialized, ';s:') + 3;
            \preg_match('~[0-9]+~', $serialized, $matches, 0, $primarySourcePosition);
            $primarySourceLength = $matches[0];
            $primarySourcePosition += \strlen($primarySourceLength) + 2;
            $primarySource = \substr($serialized, $primarySourcePosition, (int) $primarySourceLength);
            $primarySourceReversed = '';
            foreach (\str_split($primarySource, $[BytesPerElement]) as $chunk) {
                $primarySourceReversed .= \strrev($chunk);
            }
            $serialized = \substr_replace($serialized, $primarySourceReversed, $primarySourcePosition, $primarySourceLength);
            
            self::assertSerialization($sequence, $serialized);
        }
    })
    
    private static function assertSerialization($expected, string $serialized): void
    {
        $actualUnserialized = \unserialize(
            $serialized,
            ['allowed_classes' => [\ltrim($[FullyQualifiedClassName], '\\')]]
        );
        
        $actual = [];
        foreach ($actualUnserialized as $index => $element) {
            $actual[$index] = $element;
        }
        self::assertSame($expected, $actual);
    }
}