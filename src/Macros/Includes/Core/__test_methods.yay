<?php

$(macro :unsafe) {
    __test_methods()
} >> {
    private const INVALID_VALUE = $$(expand(
        $<Integer>{ '0' }
        $<!Integer>{ 0 }
    ));
    
    private static function getInstance(): \Vectory\VectorInterface
    {
        return new $[Fqn]();
    }
    
    private static function getRandomValue()
    {
        $$(expand(
            $<Boolean>{
                return [false, true][\mt_rand(0, 1)];
            }
            $<Integer>{
                $<Signed>{
                    $positive = 0 === \mt_rand(0, 1);
                    $value = \dechex(\mt_rand(0x0, $positive ? 0x7f : 0x80));
                }
                $<!Signed>{
                    $value = \dechex(\mt_rand(0x0, 0xff));
                }
                
                for ($i = 1; $i < $[BytesPerElement]; ++$i) {
                    $value .= \str_pad(\dechex(\mt_rand(0x0, 0xff)), 2, '0', \STR_PAD_LEFT);
                }
                $value = \hexdec($value);
                
                $<Signed>{
                    return $positive ? $value : -$value;
                }
                $<!Signed>{
                    return $value;
                }
            }
            $<String>{
                $value = '';
                for ($i = 0; $i < $[BytesPerElement]; ++$i) {
                    $value .= \chr(\mt_rand(0x0, 0xff));
                }
                return $value;
            }
        ))
    }
        
    $$(expand(
        $<String>{
            private static function getRandomUtf8String(): string
            {
                \assert(0x10ffff <= \mt_getrandmax());
                $string = '';
                while (\strlen($string) < $[BytesPerElement]) {
                    $characterMaxLength = \min(4, $[BytesPerElement] - \strlen($string));
                    $character = '';
                    switch (\mt_rand(1, $characterMaxLength)) {
                        case 1:
                            $character = \mb_chr(\mt_rand(0x0, 0x7f));
                            break;
                            
                        case 2:
                            $character = \mb_chr(\mt_rand(0x80, 0x7ff));
                            break;
                            
                        case 3:
                            $character = \mb_chr(\mt_rand(0x800, 0xffff));
                            break;

                        case 4:
                            $character = \mb_chr(\mt_rand(0x10000, 0x10ffff));
                            break;
                    }
                    $string .= $character;
                }
                return $string;
            }
        }
    ))
    
    private static function assertSequence(array $sequence, \Vectory\VectorInterface $vector): void
    {
        self::assertCount(\count($sequence), $vector);
        $i = 0;
        foreach ($vector as $index => $element) {
            self::assertSame($i, $index);
            self::assertSame(
                $sequence[$index],
                $element,
                'Index: '.$index."\n".
                    var_export($sequence, true)."\n".
                    self::getVectorDump($vector)
            );
            ++$i;
        }
    }
    
    private static function getVectorDump(VectorInterface $vector): string
    {
        $dump = "\n";
        $trace = \array_reverse(debug_backtrace(\DEBUG_BACKTRACE_IGNORE_ARGS));
        foreach ($trace as $frame) {
            if (0 === \strpos($frame['class'], 'Vectory')) {
                $frame['class'] = \substr($frame['class'], \strrpos($frame['class'], '\\') + 1);
                $dump .= \sprintf("%s%s%s:%d\n", $frame['class'], $frame['type'], $frame['function'], $frame['line']);
            }
        }
        
        $sources = ['primary'];
        $<Nullable>{
            $sources[] = 'nullability';
        }
        foreach ($sources as $sourcePrefix) {
            $property = new \ReflectionProperty($vector, $sourcePrefix.'Source');
            $property->setAccessible(true);
            $source = $property->getValue($vector);
            $bytesPerElement = $[BytesPerElement] ?? 1;
            $elements = \str_split(\bin2hex($source), $bytesPerElement * 2);
            \assert(\is_iterable($elements));
            foreach ($elements as $index => $element) {
                $dump .= \substr(\strtoupper($sourcePrefix), 0, 1);
                $dump .= \sprintf('% '.\strlen((string) (\strlen($source) / $bytesPerElement)).'d: ', $index);
                foreach (\str_split($element, 2) as $value) {
                    $decimal = (int) \hexdec($value);
                    $binary = \str_pad(\decbin($decimal), 8, '0', \STR_PAD_LEFT);
                    $dump .= \sprintf('h:% 2s d:% 3s b:%04s %04s | ', $value, $decimal, \substr($binary, 0, 4), \substr($binary, 4));
                }
                $dump .= "\n";
            }
        }
        return $dump;
    }
    
    private static function dumpVector(\Vectory\VectorInterface $vector): void
    {
        echo self::getVectorDump($vector);
    }
}